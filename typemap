ZOOM_connection					T_PTROBJ
ZOOM_connection *				T_PTROBJ
ZOOM_options					T_PTROBJ
ZOOM_options_callback				T_PTROBJ
ZOOM_package					T_PTROBJ
ZOOM_query					T_PTROBJ
ZOOM_record					T_PTROBJ
ZOOM_record *					T_PTROBJ
ZOOM_resultset					T_PTROBJ
ZOOM_scanset					T_PTROBJ
__compar_fn_t					T_PTROBJ
__const char *					T_PTROBJ
__const void *					T_PTROBJ
__const wchar_t *				T_PTROBJ
__extension__ extern lldiv_t			T_PTROBJ
__extension__ extern long long int		T_PTROBJ
__extension__ extern unsigned long long int	T_PTROBJ
__locale_t					T_PTROBJ
char * __const *				T_PTROBJ
const __sigset_t *				T_PTROBJ
# The next line was originally autogenerated by h2xs, which gave the
# type of "const char *" as T_PTROBJ -- a pointer to an opaque object.
# This prevented the return value of ZOOM_record_get() from being
# translated into a Perl string.  Instead, I am using T_PV, which
# works properly.  This also has the pleasant side-effect that I no
# longer have to discard the "const" qualfiers from the arguments to
# the functions in the .xs file.
const char *					T_PV
opaquechar *					T_OPAQUECHAR
const char **					T_PTROBJ
const struct timespec *				T_PTROBJ
div_t						T_OPAQUE_STRUCT
double *					T_PTROBJ
fd_set *					T_PTROBJ
int *						T_PTROBJ
int32_t *					T_PTROBJ
ldiv_t						T_OPAQUE_STRUCT
long double					T_NV
long int					T_PTROBJ
long int *					T_PTROBJ
long long int					T_PTROBJ
struct drand48_data *				T_PTROBJ
struct random_data *				T_PTROBJ
struct timeval *				T_PTROBJ
unsigned int *					T_PTROBJ
unsigned long int				T_PTROBJ
unsigned short int				T_PTROBJ
unsigned short int *				T_PTROBJ
void ( * __func ) ( int __status, void * __arg )	T_PTROBJ
void ( * __func ) ( void )			T_PTROBJ
void **						T_PTROBJ
struct datachunk				T_DATACHUNK
# ---------------------------------------------------------------------------
INPUT
T_OPAQUE_STRUCT
	if (sv_derived_from($arg, \"${ntype}\")) {
	    STRLEN len;
	    char  *s = SvPV((SV*)SvRV($arg), len);

	    if (len != sizeof($var))
		croak(\"Size %d of packed data != expected %d\",
			len, sizeof($var));
	    $var = *($type *)s;
	}
	else
	    croak(\"$var is not of type ${ntype}\")
T_OPAQUECHAR
	{ STRLEN _unused_len;
	$var = ($type) SvPV($arg, _unused_len); }

# ---------------------------------------------------------------------------
OUTPUT
T_OPAQUE_STRUCT
	sv_setref_pvn($arg, \"${ntype}\", (char *)&$var, sizeof($var));
T_DATACHUNK
	sv_setpvn($arg, $var.data, $var.len);
